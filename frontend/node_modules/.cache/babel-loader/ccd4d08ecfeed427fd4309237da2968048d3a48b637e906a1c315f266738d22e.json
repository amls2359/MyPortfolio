{"ast":null,"code":"import _objectSpread from \"C:/Users/user/Desktop/React-Login/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { $ZodRegistry, globalRegistry } from \"./registries.js\";\nimport { getEnumValues } from \"./util.js\";\nexport class JSONSchemaGenerator {\n  constructor(params) {\n    var _params$metadata, _params$target, _params$unrepresentab, _params$override, _params$io;\n    this.counter = 0;\n    this.metadataRegistry = (_params$metadata = params === null || params === void 0 ? void 0 : params.metadata) !== null && _params$metadata !== void 0 ? _params$metadata : globalRegistry;\n    this.target = (_params$target = params === null || params === void 0 ? void 0 : params.target) !== null && _params$target !== void 0 ? _params$target : \"draft-2020-12\";\n    this.unrepresentable = (_params$unrepresentab = params === null || params === void 0 ? void 0 : params.unrepresentable) !== null && _params$unrepresentab !== void 0 ? _params$unrepresentab : \"throw\";\n    this.override = (_params$override = params === null || params === void 0 ? void 0 : params.override) !== null && _params$override !== void 0 ? _params$override : () => {};\n    this.io = (_params$io = params === null || params === void 0 ? void 0 : params.io) !== null && _params$io !== void 0 ? _params$io : \"output\";\n    this.seen = new Map();\n  }\n  process(schema) {\n    var _schema$_zod$toJSONSc, _schema$_zod, _a$default;\n    let _params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      path: [],\n      schemaPath: []\n    };\n    var _a;\n    const def = schema._zod.def;\n    const formatMap = {\n      guid: \"uuid\",\n      url: \"uri\",\n      datetime: \"date-time\",\n      json_string: \"json-string\",\n      regex: \"\" // do not set\n    };\n    // check for schema in seens\n    const seen = this.seen.get(schema);\n    if (seen) {\n      seen.count++;\n      // check if cycle\n      const isCycle = _params.schemaPath.includes(schema);\n      if (isCycle) {\n        seen.cycle = _params.path;\n      }\n      return seen.schema;\n    }\n    // initialize\n    const result = {\n      schema: {},\n      count: 1,\n      cycle: undefined,\n      path: _params.path\n    };\n    this.seen.set(schema, result);\n    // custom method overrides default behavior\n    const overrideSchema = (_schema$_zod$toJSONSc = (_schema$_zod = schema._zod).toJSONSchema) === null || _schema$_zod$toJSONSc === void 0 ? void 0 : _schema$_zod$toJSONSc.call(_schema$_zod);\n    if (overrideSchema) {\n      result.schema = overrideSchema;\n    } else {\n      const params = _objectSpread(_objectSpread({}, _params), {}, {\n        schemaPath: [..._params.schemaPath, schema],\n        path: _params.path\n      });\n      const parent = schema._zod.parent;\n      if (parent) {\n        // schema was cloned from another schema\n        result.ref = parent;\n        this.process(parent, params);\n        this.seen.get(parent).isParent = true;\n      } else {\n        const _json = result.schema;\n        switch (def.type) {\n          case \"string\":\n            {\n              const json = _json;\n              json.type = \"string\";\n              const {\n                minimum,\n                maximum,\n                format,\n                patterns,\n                contentEncoding\n              } = schema._zod.bag;\n              if (typeof minimum === \"number\") json.minLength = minimum;\n              if (typeof maximum === \"number\") json.maxLength = maximum;\n              // custom pattern overrides format\n              if (format) {\n                var _formatMap$format;\n                json.format = (_formatMap$format = formatMap[format]) !== null && _formatMap$format !== void 0 ? _formatMap$format : format;\n                if (json.format === \"\") delete json.format; // empty format is not valid\n              }\n              if (contentEncoding) json.contentEncoding = contentEncoding;\n              if (patterns && patterns.size > 0) {\n                const regexes = [...patterns];\n                if (regexes.length === 1) json.pattern = regexes[0].source;else if (regexes.length > 1) {\n                  result.schema.allOf = [...regexes.map(regex => _objectSpread(_objectSpread({}, this.target === \"draft-7\" || this.target === \"draft-4\" || this.target === \"openapi-3.0\" ? {\n                    type: \"string\"\n                  } : {}), {}, {\n                    pattern: regex.source\n                  }))];\n                }\n              }\n              break;\n            }\n          case \"number\":\n            {\n              const json = _json;\n              const {\n                minimum,\n                maximum,\n                format,\n                multipleOf,\n                exclusiveMaximum,\n                exclusiveMinimum\n              } = schema._zod.bag;\n              if (typeof format === \"string\" && format.includes(\"int\")) json.type = \"integer\";else json.type = \"number\";\n              if (typeof exclusiveMinimum === \"number\") {\n                if (this.target === \"draft-4\" || this.target === \"openapi-3.0\") {\n                  json.minimum = exclusiveMinimum;\n                  json.exclusiveMinimum = true;\n                } else {\n                  json.exclusiveMinimum = exclusiveMinimum;\n                }\n              }\n              if (typeof minimum === \"number\") {\n                json.minimum = minimum;\n                if (typeof exclusiveMinimum === \"number\" && this.target !== \"draft-4\") {\n                  if (exclusiveMinimum >= minimum) delete json.minimum;else delete json.exclusiveMinimum;\n                }\n              }\n              if (typeof exclusiveMaximum === \"number\") {\n                if (this.target === \"draft-4\" || this.target === \"openapi-3.0\") {\n                  json.maximum = exclusiveMaximum;\n                  json.exclusiveMaximum = true;\n                } else {\n                  json.exclusiveMaximum = exclusiveMaximum;\n                }\n              }\n              if (typeof maximum === \"number\") {\n                json.maximum = maximum;\n                if (typeof exclusiveMaximum === \"number\" && this.target !== \"draft-4\") {\n                  if (exclusiveMaximum <= maximum) delete json.maximum;else delete json.exclusiveMaximum;\n                }\n              }\n              if (typeof multipleOf === \"number\") json.multipleOf = multipleOf;\n              break;\n            }\n          case \"boolean\":\n            {\n              const json = _json;\n              json.type = \"boolean\";\n              break;\n            }\n          case \"bigint\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"BigInt cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"symbol\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Symbols cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"null\":\n            {\n              if (this.target === \"openapi-3.0\") {\n                _json.type = \"string\";\n                _json.nullable = true;\n                _json.enum = [null];\n              } else _json.type = \"null\";\n              break;\n            }\n          case \"any\":\n            {\n              break;\n            }\n          case \"unknown\":\n            {\n              break;\n            }\n          case \"undefined\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Undefined cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"void\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Void cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"never\":\n            {\n              _json.not = {};\n              break;\n            }\n          case \"date\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Date cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"array\":\n            {\n              const json = _json;\n              const {\n                minimum,\n                maximum\n              } = schema._zod.bag;\n              if (typeof minimum === \"number\") json.minItems = minimum;\n              if (typeof maximum === \"number\") json.maxItems = maximum;\n              json.type = \"array\";\n              json.items = this.process(def.element, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"items\"]\n              }));\n              break;\n            }\n          case \"object\":\n            {\n              var _def$catchall;\n              const json = _json;\n              json.type = \"object\";\n              json.properties = {};\n              const shape = def.shape; // params.shapeCache.get(schema)!;\n              for (const key in shape) {\n                json.properties[key] = this.process(shape[key], _objectSpread(_objectSpread({}, params), {}, {\n                  path: [...params.path, \"properties\", key]\n                }));\n              }\n              // required keys\n              const allKeys = new Set(Object.keys(shape));\n              // const optionalKeys = new Set(def.optional);\n              const requiredKeys = new Set([...allKeys].filter(key => {\n                const v = def.shape[key]._zod;\n                if (this.io === \"input\") {\n                  return v.optin === undefined;\n                } else {\n                  return v.optout === undefined;\n                }\n              }));\n              if (requiredKeys.size > 0) {\n                json.required = Array.from(requiredKeys);\n              }\n              // catchall\n              if (((_def$catchall = def.catchall) === null || _def$catchall === void 0 ? void 0 : _def$catchall._zod.def.type) === \"never\") {\n                // strict\n                json.additionalProperties = false;\n              } else if (!def.catchall) {\n                // regular\n                if (this.io === \"output\") json.additionalProperties = false;\n              } else if (def.catchall) {\n                json.additionalProperties = this.process(def.catchall, _objectSpread(_objectSpread({}, params), {}, {\n                  path: [...params.path, \"additionalProperties\"]\n                }));\n              }\n              break;\n            }\n          case \"union\":\n            {\n              const json = _json;\n              const options = def.options.map((x, i) => this.process(x, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"anyOf\", i]\n              })));\n              json.anyOf = options;\n              break;\n            }\n          case \"intersection\":\n            {\n              const json = _json;\n              const a = this.process(def.left, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"allOf\", 0]\n              }));\n              const b = this.process(def.right, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"allOf\", 1]\n              }));\n              const isSimpleIntersection = val => \"allOf\" in val && Object.keys(val).length === 1;\n              const allOf = [...(isSimpleIntersection(a) ? a.allOf : [a]), ...(isSimpleIntersection(b) ? b.allOf : [b])];\n              json.allOf = allOf;\n              break;\n            }\n          case \"tuple\":\n            {\n              const json = _json;\n              json.type = \"array\";\n              const prefixPath = this.target === \"draft-2020-12\" ? \"prefixItems\" : \"items\";\n              const restPath = this.target === \"draft-2020-12\" ? \"items\" : this.target === \"openapi-3.0\" ? \"items\" : \"additionalItems\";\n              const prefixItems = def.items.map((x, i) => this.process(x, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, prefixPath, i]\n              })));\n              const rest = def.rest ? this.process(def.rest, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, restPath, ...(this.target === \"openapi-3.0\" ? [def.items.length] : [])]\n              })) : null;\n              if (this.target === \"draft-2020-12\") {\n                json.prefixItems = prefixItems;\n                if (rest) {\n                  json.items = rest;\n                }\n              } else if (this.target === \"openapi-3.0\") {\n                json.items = {\n                  anyOf: prefixItems\n                };\n                if (rest) {\n                  json.items.anyOf.push(rest);\n                }\n                json.minItems = prefixItems.length;\n                if (!rest) {\n                  json.maxItems = prefixItems.length;\n                }\n              } else {\n                json.items = prefixItems;\n                if (rest) {\n                  json.additionalItems = rest;\n                }\n              }\n              // length\n              const {\n                minimum,\n                maximum\n              } = schema._zod.bag;\n              if (typeof minimum === \"number\") json.minItems = minimum;\n              if (typeof maximum === \"number\") json.maxItems = maximum;\n              break;\n            }\n          case \"record\":\n            {\n              const json = _json;\n              json.type = \"object\";\n              if (this.target === \"draft-7\" || this.target === \"draft-2020-12\") {\n                json.propertyNames = this.process(def.keyType, _objectSpread(_objectSpread({}, params), {}, {\n                  path: [...params.path, \"propertyNames\"]\n                }));\n              }\n              json.additionalProperties = this.process(def.valueType, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"additionalProperties\"]\n              }));\n              break;\n            }\n          case \"map\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Map cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"set\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Set cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"enum\":\n            {\n              const json = _json;\n              const values = getEnumValues(def.entries);\n              // Number enums can have both string and number values\n              if (values.every(v => typeof v === \"number\")) json.type = \"number\";\n              if (values.every(v => typeof v === \"string\")) json.type = \"string\";\n              json.enum = values;\n              break;\n            }\n          case \"literal\":\n            {\n              const json = _json;\n              const vals = [];\n              for (const val of def.values) {\n                if (val === undefined) {\n                  if (this.unrepresentable === \"throw\") {\n                    throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n                  } else {\n                    // do not add to vals\n                  }\n                } else if (typeof val === \"bigint\") {\n                  if (this.unrepresentable === \"throw\") {\n                    throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n                  } else {\n                    vals.push(Number(val));\n                  }\n                } else {\n                  vals.push(val);\n                }\n              }\n              if (vals.length === 0) {\n                // do nothing (an undefined literal was stripped)\n              } else if (vals.length === 1) {\n                const val = vals[0];\n                json.type = val === null ? \"null\" : typeof val;\n                if (this.target === \"draft-4\" || this.target === \"openapi-3.0\") {\n                  json.enum = [val];\n                } else {\n                  json.const = val;\n                }\n              } else {\n                if (vals.every(v => typeof v === \"number\")) json.type = \"number\";\n                if (vals.every(v => typeof v === \"string\")) json.type = \"string\";\n                if (vals.every(v => typeof v === \"boolean\")) json.type = \"string\";\n                if (vals.every(v => v === null)) json.type = \"null\";\n                json.enum = vals;\n              }\n              break;\n            }\n          case \"file\":\n            {\n              const json = _json;\n              const file = {\n                type: \"string\",\n                format: \"binary\",\n                contentEncoding: \"binary\"\n              };\n              const {\n                minimum,\n                maximum,\n                mime\n              } = schema._zod.bag;\n              if (minimum !== undefined) file.minLength = minimum;\n              if (maximum !== undefined) file.maxLength = maximum;\n              if (mime) {\n                if (mime.length === 1) {\n                  file.contentMediaType = mime[0];\n                  Object.assign(json, file);\n                } else {\n                  json.anyOf = mime.map(m => {\n                    const mFile = _objectSpread(_objectSpread({}, file), {}, {\n                      contentMediaType: m\n                    });\n                    return mFile;\n                  });\n                }\n              } else {\n                Object.assign(json, file);\n              }\n              // if (this.unrepresentable === \"throw\") {\n              //   throw new Error(\"File cannot be represented in JSON Schema\");\n              // }\n              break;\n            }\n          case \"transform\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Transforms cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"nullable\":\n            {\n              const inner = this.process(def.innerType, params);\n              if (this.target === \"openapi-3.0\") {\n                result.ref = def.innerType;\n                _json.nullable = true;\n              } else {\n                _json.anyOf = [inner, {\n                  type: \"null\"\n                }];\n              }\n              break;\n            }\n          case \"nonoptional\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              break;\n            }\n          case \"success\":\n            {\n              const json = _json;\n              json.type = \"boolean\";\n              break;\n            }\n          case \"default\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              _json.default = JSON.parse(JSON.stringify(def.defaultValue));\n              break;\n            }\n          case \"prefault\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              if (this.io === \"input\") _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n              break;\n            }\n          case \"catch\":\n            {\n              // use conditionals\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              let catchValue;\n              try {\n                catchValue = def.catchValue(undefined);\n              } catch (_unused) {\n                throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n              }\n              _json.default = catchValue;\n              break;\n            }\n          case \"nan\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"NaN cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"template_literal\":\n            {\n              const json = _json;\n              const pattern = schema._zod.pattern;\n              if (!pattern) throw new Error(\"Pattern not found in template literal\");\n              json.type = \"string\";\n              json.pattern = pattern.source;\n              break;\n            }\n          case \"pipe\":\n            {\n              const innerType = this.io === \"input\" ? def.in._zod.def.type === \"transform\" ? def.out : def.in : def.out;\n              this.process(innerType, params);\n              result.ref = innerType;\n              break;\n            }\n          case \"readonly\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              _json.readOnly = true;\n              break;\n            }\n          // passthrough types\n          case \"promise\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              break;\n            }\n          case \"optional\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              break;\n            }\n          case \"lazy\":\n            {\n              const innerType = schema._zod.innerType;\n              this.process(innerType, params);\n              result.ref = innerType;\n              break;\n            }\n          case \"custom\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Custom types cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"function\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Function types cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          default:\n            {\n              def;\n            }\n        }\n      }\n    }\n    // metadata\n    const meta = this.metadataRegistry.get(schema);\n    if (meta) Object.assign(result.schema, meta);\n    if (this.io === \"input\" && isTransforming(schema)) {\n      // examples/defaults only apply to output type of pipe\n      delete result.schema.examples;\n      delete result.schema.default;\n    }\n    // set prefault as default\n    if (this.io === \"input\" && result.schema._prefault) (_a$default = (_a = result.schema).default) !== null && _a$default !== void 0 ? _a$default : _a.default = result.schema._prefault;\n    delete result.schema._prefault;\n    // pulling fresh from this.seen in case it was overwritten\n    const _result = this.seen.get(schema);\n    return _result.schema;\n  }\n  emit(schema, _params) {\n    var _params$cycles, _params$reused, _params$external, _params$external2, _params$external$defs, _params$external3;\n    const params = {\n      cycles: (_params$cycles = _params === null || _params === void 0 ? void 0 : _params.cycles) !== null && _params$cycles !== void 0 ? _params$cycles : \"ref\",\n      reused: (_params$reused = _params === null || _params === void 0 ? void 0 : _params.reused) !== null && _params$reused !== void 0 ? _params$reused : \"inline\",\n      // unrepresentable: _params?.unrepresentable ?? \"throw\",\n      // uri: _params?.uri ?? ((id) => `${id}`),\n      external: (_params$external = _params === null || _params === void 0 ? void 0 : _params.external) !== null && _params$external !== void 0 ? _params$external : undefined\n    };\n    // iterate over seen map;\n    const root = this.seen.get(schema);\n    if (!root) throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n    // initialize result with root schema fields\n    // Object.assign(result, seen.cached);\n    // returns a ref to the schema\n    // defId will be empty if the ref points to an external schema (or #)\n    const makeURI = entry => {\n      var _entry$1$schema$id;\n      // comparing the seen objects because sometimes\n      // multiple schemas map to the same seen object.\n      // e.g. lazy\n      // external is configured\n      const defsSegment = this.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      if (params.external) {\n        var _params$external$regi, _params$external$uri, _ref, _entry$1$defId;\n        const externalId = (_params$external$regi = params.external.registry.get(entry[0])) === null || _params$external$regi === void 0 ? void 0 : _params$external$regi.id; // ?? \"__shared\";// `__schema${this.counter++}`;\n        // check if schema is in the external registry\n        const uriGenerator = (_params$external$uri = params.external.uri) !== null && _params$external$uri !== void 0 ? _params$external$uri : id => id;\n        if (externalId) {\n          return {\n            ref: uriGenerator(externalId)\n          };\n        }\n        // otherwise, add to __shared\n        const id = (_ref = (_entry$1$defId = entry[1].defId) !== null && _entry$1$defId !== void 0 ? _entry$1$defId : entry[1].schema.id) !== null && _ref !== void 0 ? _ref : \"schema\".concat(this.counter++);\n        entry[1].defId = id; // set defId so it will be reused if needed\n        return {\n          defId: id,\n          ref: \"\".concat(uriGenerator(\"__shared\"), \"#/\").concat(defsSegment, \"/\").concat(id)\n        };\n      }\n      if (entry[1] === root) {\n        return {\n          ref: \"#\"\n        };\n      }\n      // self-contained schema\n      const uriPrefix = \"#\";\n      const defUriPrefix = \"\".concat(uriPrefix, \"/\").concat(defsSegment, \"/\");\n      const defId = (_entry$1$schema$id = entry[1].schema.id) !== null && _entry$1$schema$id !== void 0 ? _entry$1$schema$id : \"__schema\".concat(this.counter++);\n      return {\n        defId,\n        ref: defUriPrefix + defId\n      };\n    };\n    // stored cached version in `def` property\n    // remove all properties, set $ref\n    const extractToDef = entry => {\n      // if the schema is already a reference, do not extract it\n      if (entry[1].schema.$ref) {\n        return;\n      }\n      const seen = entry[1];\n      const {\n        ref,\n        defId\n      } = makeURI(entry);\n      seen.def = _objectSpread({}, seen.schema);\n      // defId won't be set if the schema is a reference to an external schema\n      if (defId) seen.defId = defId;\n      // wipe away all properties except $ref\n      const schema = seen.schema;\n      for (const key in schema) {\n        delete schema[key];\n      }\n      schema.$ref = ref;\n    };\n    // throw on cycles\n    // break cycles\n    if (params.cycles === \"throw\") {\n      for (const entry of this.seen.entries()) {\n        const seen = entry[1];\n        if (seen.cycle) {\n          var _seen$cycle;\n          throw new Error(\"Cycle detected: \" + \"#/\".concat((_seen$cycle = seen.cycle) === null || _seen$cycle === void 0 ? void 0 : _seen$cycle.join(\"/\"), \"/<root>\") + '\\n\\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.');\n        }\n      }\n    }\n    // extract schemas into $defs\n    for (const entry of this.seen.entries()) {\n      var _this$metadataRegistr;\n      const seen = entry[1];\n      // convert root schema to # $ref\n      if (schema === entry[0]) {\n        extractToDef(entry); // this has special handling for the root schema\n        continue;\n      }\n      // extract schemas that are in the external registry\n      if (params.external) {\n        var _params$external$regi2;\n        const ext = (_params$external$regi2 = params.external.registry.get(entry[0])) === null || _params$external$regi2 === void 0 ? void 0 : _params$external$regi2.id;\n        if (schema !== entry[0] && ext) {\n          extractToDef(entry);\n          continue;\n        }\n      }\n      // extract schemas with `id` meta\n      const id = (_this$metadataRegistr = this.metadataRegistry.get(entry[0])) === null || _this$metadataRegistr === void 0 ? void 0 : _this$metadataRegistr.id;\n      if (id) {\n        extractToDef(entry);\n        continue;\n      }\n      // break cycles\n      if (seen.cycle) {\n        // any\n        extractToDef(entry);\n        continue;\n      }\n      // extract reused schemas\n      if (seen.count > 1) {\n        if (params.reused === \"ref\") {\n          extractToDef(entry);\n          // biome-ignore lint:\n          continue;\n        }\n      }\n    }\n    // flatten _refs\n    const flattenRef = (zodSchema, params) => {\n      var _seen$def, _seen$path;\n      const seen = this.seen.get(zodSchema);\n      const schema = (_seen$def = seen.def) !== null && _seen$def !== void 0 ? _seen$def : seen.schema;\n      const _cached = _objectSpread({}, schema);\n      // already seen\n      if (seen.ref === null) {\n        return;\n      }\n      // flatten ref if defined\n      const ref = seen.ref;\n      seen.ref = null; // prevent recursion\n      if (ref) {\n        flattenRef(ref, params);\n        // merge referenced schema into current\n        const refSchema = this.seen.get(ref).schema;\n        if (refSchema.$ref && (params.target === \"draft-7\" || params.target === \"draft-4\" || params.target === \"openapi-3.0\")) {\n          var _schema$allOf;\n          schema.allOf = (_schema$allOf = schema.allOf) !== null && _schema$allOf !== void 0 ? _schema$allOf : [];\n          schema.allOf.push(refSchema);\n        } else {\n          Object.assign(schema, refSchema);\n          Object.assign(schema, _cached); // prevent overwriting any fields in the original schema\n        }\n      }\n      // execute overrides\n      if (!seen.isParent) this.override({\n        zodSchema: zodSchema,\n        jsonSchema: schema,\n        path: (_seen$path = seen.path) !== null && _seen$path !== void 0 ? _seen$path : []\n      });\n    };\n    for (const entry of [...this.seen.entries()].reverse()) {\n      flattenRef(entry[0], {\n        target: this.target\n      });\n    }\n    const result = {};\n    if (this.target === \"draft-2020-12\") {\n      result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n    } else if (this.target === \"draft-7\") {\n      result.$schema = \"http://json-schema.org/draft-07/schema#\";\n    } else if (this.target === \"draft-4\") {\n      result.$schema = \"http://json-schema.org/draft-04/schema#\";\n    } else if (this.target === \"openapi-3.0\") {\n      // OpenAPI 3.0 schema objects should not include a $schema property\n    } else {\n      // @ts-ignore\n      console.warn(\"Invalid target: \".concat(this.target));\n    }\n    if ((_params$external2 = params.external) !== null && _params$external2 !== void 0 && _params$external2.uri) {\n      var _params$external$regi3;\n      const id = (_params$external$regi3 = params.external.registry.get(schema)) === null || _params$external$regi3 === void 0 ? void 0 : _params$external$regi3.id;\n      if (!id) throw new Error(\"Schema is missing an `id` property\");\n      result.$id = params.external.uri(id);\n    }\n    Object.assign(result, root.def);\n    // build defs object\n    const defs = (_params$external$defs = (_params$external3 = params.external) === null || _params$external3 === void 0 ? void 0 : _params$external3.defs) !== null && _params$external$defs !== void 0 ? _params$external$defs : {};\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n      if (seen.def && seen.defId) {\n        defs[seen.defId] = seen.def;\n      }\n    }\n    // set definitions in result\n    if (params.external) {} else {\n      if (Object.keys(defs).length > 0) {\n        if (this.target === \"draft-2020-12\") {\n          result.$defs = defs;\n        } else {\n          result.definitions = defs;\n        }\n      }\n    }\n    try {\n      // this \"finalizes\" this schema and ensures all cycles are removed\n      // each call to .emit() is functionally independent\n      // though the seen map is shared\n      return JSON.parse(JSON.stringify(result));\n    } catch (_err) {\n      throw new Error(\"Error converting schema to JSON.\");\n    }\n  }\n}\nexport function toJSONSchema(input, _params) {\n  if (input instanceof $ZodRegistry) {\n    const gen = new JSONSchemaGenerator(_params);\n    const defs = {};\n    for (const entry of input._idmap.entries()) {\n      const [_, schema] = entry;\n      gen.process(schema);\n    }\n    const schemas = {};\n    const external = {\n      registry: input,\n      uri: _params === null || _params === void 0 ? void 0 : _params.uri,\n      defs\n    };\n    for (const entry of input._idmap.entries()) {\n      const [key, schema] = entry;\n      schemas[key] = gen.emit(schema, _objectSpread(_objectSpread({}, _params), {}, {\n        external\n      }));\n    }\n    if (Object.keys(defs).length > 0) {\n      const defsSegment = gen.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      schemas.__shared = {\n        [defsSegment]: defs\n      };\n    }\n    return {\n      schemas\n    };\n  }\n  const gen = new JSONSchemaGenerator(_params);\n  gen.process(input);\n  return gen.emit(input, _params);\n}\nfunction isTransforming(_schema, _ctx) {\n  const ctx = _ctx !== null && _ctx !== void 0 ? _ctx : {\n    seen: new Set()\n  };\n  if (ctx.seen.has(_schema)) return false;\n  ctx.seen.add(_schema);\n  const schema = _schema;\n  const def = schema._zod.def;\n  switch (def.type) {\n    case \"string\":\n    case \"number\":\n    case \"bigint\":\n    case \"boolean\":\n    case \"date\":\n    case \"symbol\":\n    case \"undefined\":\n    case \"null\":\n    case \"any\":\n    case \"unknown\":\n    case \"never\":\n    case \"void\":\n    case \"literal\":\n    case \"enum\":\n    case \"nan\":\n    case \"file\":\n    case \"template_literal\":\n      return false;\n    case \"array\":\n      {\n        return isTransforming(def.element, ctx);\n      }\n    case \"object\":\n      {\n        for (const key in def.shape) {\n          if (isTransforming(def.shape[key], ctx)) return true;\n        }\n        return false;\n      }\n    case \"union\":\n      {\n        for (const option of def.options) {\n          if (isTransforming(option, ctx)) return true;\n        }\n        return false;\n      }\n    case \"intersection\":\n      {\n        return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n      }\n    case \"tuple\":\n      {\n        for (const item of def.items) {\n          if (isTransforming(item, ctx)) return true;\n        }\n        if (def.rest && isTransforming(def.rest, ctx)) return true;\n        return false;\n      }\n    case \"record\":\n      {\n        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n      }\n    case \"map\":\n      {\n        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n      }\n    case \"set\":\n      {\n        return isTransforming(def.valueType, ctx);\n      }\n    // inner types\n    case \"promise\":\n    case \"optional\":\n    case \"nonoptional\":\n    case \"nullable\":\n    case \"readonly\":\n      return isTransforming(def.innerType, ctx);\n    case \"lazy\":\n      return isTransforming(def.getter(), ctx);\n    case \"default\":\n      {\n        return isTransforming(def.innerType, ctx);\n      }\n    case \"prefault\":\n      {\n        return isTransforming(def.innerType, ctx);\n      }\n    case \"custom\":\n      {\n        return false;\n      }\n    case \"transform\":\n      {\n        return true;\n      }\n    case \"pipe\":\n      {\n        return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n      }\n    case \"success\":\n      {\n        return false;\n      }\n    case \"catch\":\n      {\n        return false;\n      }\n    case \"function\":\n      {\n        return false;\n      }\n    default:\n      def;\n  }\n  throw new Error(\"Unknown schema type: \".concat(def.type));\n}","map":{"version":3,"names":["$ZodRegistry","globalRegistry","getEnumValues","JSONSchemaGenerator","constructor","params","_params$metadata","_params$target","_params$unrepresentab","_params$override","_params$io","counter","metadataRegistry","metadata","target","unrepresentable","override","io","seen","Map","process","schema","_schema$_zod$toJSONSc","_schema$_zod","_a$default","_params","arguments","length","undefined","path","schemaPath","_a","def","_zod","formatMap","guid","url","datetime","json_string","regex","get","count","isCycle","includes","cycle","result","set","overrideSchema","toJSONSchema","call","_objectSpread","parent","ref","isParent","_json","type","json","minimum","maximum","format","patterns","contentEncoding","bag","minLength","maxLength","_formatMap$format","size","regexes","pattern","source","allOf","map","multipleOf","exclusiveMaximum","exclusiveMinimum","Error","nullable","enum","not","minItems","maxItems","items","element","_def$catchall","properties","shape","key","allKeys","Set","Object","keys","requiredKeys","filter","v","optin","optout","required","Array","from","catchall","additionalProperties","options","x","i","anyOf","a","left","b","right","isSimpleIntersection","val","prefixPath","restPath","prefixItems","rest","push","additionalItems","propertyNames","keyType","valueType","values","entries","every","vals","Number","const","file","mime","contentMediaType","assign","m","mFile","inner","innerType","default","JSON","parse","stringify","defaultValue","_prefault","catchValue","_unused","in","out","readOnly","meta","isTransforming","examples","_result","emit","_params$cycles","_params$reused","_params$external","_params$external2","_params$external$defs","_params$external3","cycles","reused","external","root","makeURI","entry","_entry$1$schema$id","defsSegment","_params$external$regi","_params$external$uri","_ref","_entry$1$defId","externalId","registry","id","uriGenerator","uri","defId","concat","uriPrefix","defUriPrefix","extractToDef","$ref","_seen$cycle","join","_this$metadataRegistr","_params$external$regi2","ext","flattenRef","zodSchema","_seen$def","_seen$path","_cached","refSchema","_schema$allOf","jsonSchema","reverse","$schema","console","warn","_params$external$regi3","$id","defs","$defs","definitions","_err","input","gen","_idmap","_","schemas","__shared","_schema","_ctx","ctx","has","add","option","item","getter"],"sources":["C:/Users/user/Desktop/React-Login/frontend/node_modules/zod/v4/core/to-json-schema.js"],"sourcesContent":["import { $ZodRegistry, globalRegistry } from \"./registries.js\";\nimport { getEnumValues } from \"./util.js\";\nexport class JSONSchemaGenerator {\n    constructor(params) {\n        this.counter = 0;\n        this.metadataRegistry = params?.metadata ?? globalRegistry;\n        this.target = params?.target ?? \"draft-2020-12\";\n        this.unrepresentable = params?.unrepresentable ?? \"throw\";\n        this.override = params?.override ?? (() => { });\n        this.io = params?.io ?? \"output\";\n        this.seen = new Map();\n    }\n    process(schema, _params = { path: [], schemaPath: [] }) {\n        var _a;\n        const def = schema._zod.def;\n        const formatMap = {\n            guid: \"uuid\",\n            url: \"uri\",\n            datetime: \"date-time\",\n            json_string: \"json-string\",\n            regex: \"\", // do not set\n        };\n        // check for schema in seens\n        const seen = this.seen.get(schema);\n        if (seen) {\n            seen.count++;\n            // check if cycle\n            const isCycle = _params.schemaPath.includes(schema);\n            if (isCycle) {\n                seen.cycle = _params.path;\n            }\n            return seen.schema;\n        }\n        // initialize\n        const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };\n        this.seen.set(schema, result);\n        // custom method overrides default behavior\n        const overrideSchema = schema._zod.toJSONSchema?.();\n        if (overrideSchema) {\n            result.schema = overrideSchema;\n        }\n        else {\n            const params = {\n                ..._params,\n                schemaPath: [..._params.schemaPath, schema],\n                path: _params.path,\n            };\n            const parent = schema._zod.parent;\n            if (parent) {\n                // schema was cloned from another schema\n                result.ref = parent;\n                this.process(parent, params);\n                this.seen.get(parent).isParent = true;\n            }\n            else {\n                const _json = result.schema;\n                switch (def.type) {\n                    case \"string\": {\n                        const json = _json;\n                        json.type = \"string\";\n                        const { minimum, maximum, format, patterns, contentEncoding } = schema._zod\n                            .bag;\n                        if (typeof minimum === \"number\")\n                            json.minLength = minimum;\n                        if (typeof maximum === \"number\")\n                            json.maxLength = maximum;\n                        // custom pattern overrides format\n                        if (format) {\n                            json.format = formatMap[format] ?? format;\n                            if (json.format === \"\")\n                                delete json.format; // empty format is not valid\n                        }\n                        if (contentEncoding)\n                            json.contentEncoding = contentEncoding;\n                        if (patterns && patterns.size > 0) {\n                            const regexes = [...patterns];\n                            if (regexes.length === 1)\n                                json.pattern = regexes[0].source;\n                            else if (regexes.length > 1) {\n                                result.schema.allOf = [\n                                    ...regexes.map((regex) => ({\n                                        ...(this.target === \"draft-7\" || this.target === \"draft-4\" || this.target === \"openapi-3.0\"\n                                            ? { type: \"string\" }\n                                            : {}),\n                                        pattern: regex.source,\n                                    })),\n                                ];\n                            }\n                        }\n                        break;\n                    }\n                    case \"number\": {\n                        const json = _json;\n                        const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;\n                        if (typeof format === \"string\" && format.includes(\"int\"))\n                            json.type = \"integer\";\n                        else\n                            json.type = \"number\";\n                        if (typeof exclusiveMinimum === \"number\") {\n                            if (this.target === \"draft-4\" || this.target === \"openapi-3.0\") {\n                                json.minimum = exclusiveMinimum;\n                                json.exclusiveMinimum = true;\n                            }\n                            else {\n                                json.exclusiveMinimum = exclusiveMinimum;\n                            }\n                        }\n                        if (typeof minimum === \"number\") {\n                            json.minimum = minimum;\n                            if (typeof exclusiveMinimum === \"number\" && this.target !== \"draft-4\") {\n                                if (exclusiveMinimum >= minimum)\n                                    delete json.minimum;\n                                else\n                                    delete json.exclusiveMinimum;\n                            }\n                        }\n                        if (typeof exclusiveMaximum === \"number\") {\n                            if (this.target === \"draft-4\" || this.target === \"openapi-3.0\") {\n                                json.maximum = exclusiveMaximum;\n                                json.exclusiveMaximum = true;\n                            }\n                            else {\n                                json.exclusiveMaximum = exclusiveMaximum;\n                            }\n                        }\n                        if (typeof maximum === \"number\") {\n                            json.maximum = maximum;\n                            if (typeof exclusiveMaximum === \"number\" && this.target !== \"draft-4\") {\n                                if (exclusiveMaximum <= maximum)\n                                    delete json.maximum;\n                                else\n                                    delete json.exclusiveMaximum;\n                            }\n                        }\n                        if (typeof multipleOf === \"number\")\n                            json.multipleOf = multipleOf;\n                        break;\n                    }\n                    case \"boolean\": {\n                        const json = _json;\n                        json.type = \"boolean\";\n                        break;\n                    }\n                    case \"bigint\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"BigInt cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"symbol\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Symbols cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"null\": {\n                        if (this.target === \"openapi-3.0\") {\n                            _json.type = \"string\";\n                            _json.nullable = true;\n                            _json.enum = [null];\n                        }\n                        else\n                            _json.type = \"null\";\n                        break;\n                    }\n                    case \"any\": {\n                        break;\n                    }\n                    case \"unknown\": {\n                        break;\n                    }\n                    case \"undefined\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Undefined cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"void\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Void cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"never\": {\n                        _json.not = {};\n                        break;\n                    }\n                    case \"date\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Date cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"array\": {\n                        const json = _json;\n                        const { minimum, maximum } = schema._zod.bag;\n                        if (typeof minimum === \"number\")\n                            json.minItems = minimum;\n                        if (typeof maximum === \"number\")\n                            json.maxItems = maximum;\n                        json.type = \"array\";\n                        json.items = this.process(def.element, { ...params, path: [...params.path, \"items\"] });\n                        break;\n                    }\n                    case \"object\": {\n                        const json = _json;\n                        json.type = \"object\";\n                        json.properties = {};\n                        const shape = def.shape; // params.shapeCache.get(schema)!;\n                        for (const key in shape) {\n                            json.properties[key] = this.process(shape[key], {\n                                ...params,\n                                path: [...params.path, \"properties\", key],\n                            });\n                        }\n                        // required keys\n                        const allKeys = new Set(Object.keys(shape));\n                        // const optionalKeys = new Set(def.optional);\n                        const requiredKeys = new Set([...allKeys].filter((key) => {\n                            const v = def.shape[key]._zod;\n                            if (this.io === \"input\") {\n                                return v.optin === undefined;\n                            }\n                            else {\n                                return v.optout === undefined;\n                            }\n                        }));\n                        if (requiredKeys.size > 0) {\n                            json.required = Array.from(requiredKeys);\n                        }\n                        // catchall\n                        if (def.catchall?._zod.def.type === \"never\") {\n                            // strict\n                            json.additionalProperties = false;\n                        }\n                        else if (!def.catchall) {\n                            // regular\n                            if (this.io === \"output\")\n                                json.additionalProperties = false;\n                        }\n                        else if (def.catchall) {\n                            json.additionalProperties = this.process(def.catchall, {\n                                ...params,\n                                path: [...params.path, \"additionalProperties\"],\n                            });\n                        }\n                        break;\n                    }\n                    case \"union\": {\n                        const json = _json;\n                        const options = def.options.map((x, i) => this.process(x, {\n                            ...params,\n                            path: [...params.path, \"anyOf\", i],\n                        }));\n                        json.anyOf = options;\n                        break;\n                    }\n                    case \"intersection\": {\n                        const json = _json;\n                        const a = this.process(def.left, {\n                            ...params,\n                            path: [...params.path, \"allOf\", 0],\n                        });\n                        const b = this.process(def.right, {\n                            ...params,\n                            path: [...params.path, \"allOf\", 1],\n                        });\n                        const isSimpleIntersection = (val) => \"allOf\" in val && Object.keys(val).length === 1;\n                        const allOf = [\n                            ...(isSimpleIntersection(a) ? a.allOf : [a]),\n                            ...(isSimpleIntersection(b) ? b.allOf : [b]),\n                        ];\n                        json.allOf = allOf;\n                        break;\n                    }\n                    case \"tuple\": {\n                        const json = _json;\n                        json.type = \"array\";\n                        const prefixPath = this.target === \"draft-2020-12\" ? \"prefixItems\" : \"items\";\n                        const restPath = this.target === \"draft-2020-12\" ? \"items\" : this.target === \"openapi-3.0\" ? \"items\" : \"additionalItems\";\n                        const prefixItems = def.items.map((x, i) => this.process(x, {\n                            ...params,\n                            path: [...params.path, prefixPath, i],\n                        }));\n                        const rest = def.rest\n                            ? this.process(def.rest, {\n                                ...params,\n                                path: [...params.path, restPath, ...(this.target === \"openapi-3.0\" ? [def.items.length] : [])],\n                            })\n                            : null;\n                        if (this.target === \"draft-2020-12\") {\n                            json.prefixItems = prefixItems;\n                            if (rest) {\n                                json.items = rest;\n                            }\n                        }\n                        else if (this.target === \"openapi-3.0\") {\n                            json.items = {\n                                anyOf: prefixItems,\n                            };\n                            if (rest) {\n                                json.items.anyOf.push(rest);\n                            }\n                            json.minItems = prefixItems.length;\n                            if (!rest) {\n                                json.maxItems = prefixItems.length;\n                            }\n                        }\n                        else {\n                            json.items = prefixItems;\n                            if (rest) {\n                                json.additionalItems = rest;\n                            }\n                        }\n                        // length\n                        const { minimum, maximum } = schema._zod.bag;\n                        if (typeof minimum === \"number\")\n                            json.minItems = minimum;\n                        if (typeof maximum === \"number\")\n                            json.maxItems = maximum;\n                        break;\n                    }\n                    case \"record\": {\n                        const json = _json;\n                        json.type = \"object\";\n                        if (this.target === \"draft-7\" || this.target === \"draft-2020-12\") {\n                            json.propertyNames = this.process(def.keyType, {\n                                ...params,\n                                path: [...params.path, \"propertyNames\"],\n                            });\n                        }\n                        json.additionalProperties = this.process(def.valueType, {\n                            ...params,\n                            path: [...params.path, \"additionalProperties\"],\n                        });\n                        break;\n                    }\n                    case \"map\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Map cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"set\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Set cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"enum\": {\n                        const json = _json;\n                        const values = getEnumValues(def.entries);\n                        // Number enums can have both string and number values\n                        if (values.every((v) => typeof v === \"number\"))\n                            json.type = \"number\";\n                        if (values.every((v) => typeof v === \"string\"))\n                            json.type = \"string\";\n                        json.enum = values;\n                        break;\n                    }\n                    case \"literal\": {\n                        const json = _json;\n                        const vals = [];\n                        for (const val of def.values) {\n                            if (val === undefined) {\n                                if (this.unrepresentable === \"throw\") {\n                                    throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n                                }\n                                else {\n                                    // do not add to vals\n                                }\n                            }\n                            else if (typeof val === \"bigint\") {\n                                if (this.unrepresentable === \"throw\") {\n                                    throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n                                }\n                                else {\n                                    vals.push(Number(val));\n                                }\n                            }\n                            else {\n                                vals.push(val);\n                            }\n                        }\n                        if (vals.length === 0) {\n                            // do nothing (an undefined literal was stripped)\n                        }\n                        else if (vals.length === 1) {\n                            const val = vals[0];\n                            json.type = val === null ? \"null\" : typeof val;\n                            if (this.target === \"draft-4\" || this.target === \"openapi-3.0\") {\n                                json.enum = [val];\n                            }\n                            else {\n                                json.const = val;\n                            }\n                        }\n                        else {\n                            if (vals.every((v) => typeof v === \"number\"))\n                                json.type = \"number\";\n                            if (vals.every((v) => typeof v === \"string\"))\n                                json.type = \"string\";\n                            if (vals.every((v) => typeof v === \"boolean\"))\n                                json.type = \"string\";\n                            if (vals.every((v) => v === null))\n                                json.type = \"null\";\n                            json.enum = vals;\n                        }\n                        break;\n                    }\n                    case \"file\": {\n                        const json = _json;\n                        const file = {\n                            type: \"string\",\n                            format: \"binary\",\n                            contentEncoding: \"binary\",\n                        };\n                        const { minimum, maximum, mime } = schema._zod.bag;\n                        if (minimum !== undefined)\n                            file.minLength = minimum;\n                        if (maximum !== undefined)\n                            file.maxLength = maximum;\n                        if (mime) {\n                            if (mime.length === 1) {\n                                file.contentMediaType = mime[0];\n                                Object.assign(json, file);\n                            }\n                            else {\n                                json.anyOf = mime.map((m) => {\n                                    const mFile = { ...file, contentMediaType: m };\n                                    return mFile;\n                                });\n                            }\n                        }\n                        else {\n                            Object.assign(json, file);\n                        }\n                        // if (this.unrepresentable === \"throw\") {\n                        //   throw new Error(\"File cannot be represented in JSON Schema\");\n                        // }\n                        break;\n                    }\n                    case \"transform\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Transforms cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"nullable\": {\n                        const inner = this.process(def.innerType, params);\n                        if (this.target === \"openapi-3.0\") {\n                            result.ref = def.innerType;\n                            _json.nullable = true;\n                        }\n                        else {\n                            _json.anyOf = [inner, { type: \"null\" }];\n                        }\n                        break;\n                    }\n                    case \"nonoptional\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        break;\n                    }\n                    case \"success\": {\n                        const json = _json;\n                        json.type = \"boolean\";\n                        break;\n                    }\n                    case \"default\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        _json.default = JSON.parse(JSON.stringify(def.defaultValue));\n                        break;\n                    }\n                    case \"prefault\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        if (this.io === \"input\")\n                            _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n                        break;\n                    }\n                    case \"catch\": {\n                        // use conditionals\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        let catchValue;\n                        try {\n                            catchValue = def.catchValue(undefined);\n                        }\n                        catch {\n                            throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n                        }\n                        _json.default = catchValue;\n                        break;\n                    }\n                    case \"nan\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"NaN cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"template_literal\": {\n                        const json = _json;\n                        const pattern = schema._zod.pattern;\n                        if (!pattern)\n                            throw new Error(\"Pattern not found in template literal\");\n                        json.type = \"string\";\n                        json.pattern = pattern.source;\n                        break;\n                    }\n                    case \"pipe\": {\n                        const innerType = this.io === \"input\" ? (def.in._zod.def.type === \"transform\" ? def.out : def.in) : def.out;\n                        this.process(innerType, params);\n                        result.ref = innerType;\n                        break;\n                    }\n                    case \"readonly\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        _json.readOnly = true;\n                        break;\n                    }\n                    // passthrough types\n                    case \"promise\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        break;\n                    }\n                    case \"optional\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        break;\n                    }\n                    case \"lazy\": {\n                        const innerType = schema._zod.innerType;\n                        this.process(innerType, params);\n                        result.ref = innerType;\n                        break;\n                    }\n                    case \"custom\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Custom types cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"function\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Function types cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    default: {\n                        def;\n                    }\n                }\n            }\n        }\n        // metadata\n        const meta = this.metadataRegistry.get(schema);\n        if (meta)\n            Object.assign(result.schema, meta);\n        if (this.io === \"input\" && isTransforming(schema)) {\n            // examples/defaults only apply to output type of pipe\n            delete result.schema.examples;\n            delete result.schema.default;\n        }\n        // set prefault as default\n        if (this.io === \"input\" && result.schema._prefault)\n            (_a = result.schema).default ?? (_a.default = result.schema._prefault);\n        delete result.schema._prefault;\n        // pulling fresh from this.seen in case it was overwritten\n        const _result = this.seen.get(schema);\n        return _result.schema;\n    }\n    emit(schema, _params) {\n        const params = {\n            cycles: _params?.cycles ?? \"ref\",\n            reused: _params?.reused ?? \"inline\",\n            // unrepresentable: _params?.unrepresentable ?? \"throw\",\n            // uri: _params?.uri ?? ((id) => `${id}`),\n            external: _params?.external ?? undefined,\n        };\n        // iterate over seen map;\n        const root = this.seen.get(schema);\n        if (!root)\n            throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n        // initialize result with root schema fields\n        // Object.assign(result, seen.cached);\n        // returns a ref to the schema\n        // defId will be empty if the ref points to an external schema (or #)\n        const makeURI = (entry) => {\n            // comparing the seen objects because sometimes\n            // multiple schemas map to the same seen object.\n            // e.g. lazy\n            // external is configured\n            const defsSegment = this.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n            if (params.external) {\n                const externalId = params.external.registry.get(entry[0])?.id; // ?? \"__shared\";// `__schema${this.counter++}`;\n                // check if schema is in the external registry\n                const uriGenerator = params.external.uri ?? ((id) => id);\n                if (externalId) {\n                    return { ref: uriGenerator(externalId) };\n                }\n                // otherwise, add to __shared\n                const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;\n                entry[1].defId = id; // set defId so it will be reused if needed\n                return { defId: id, ref: `${uriGenerator(\"__shared\")}#/${defsSegment}/${id}` };\n            }\n            if (entry[1] === root) {\n                return { ref: \"#\" };\n            }\n            // self-contained schema\n            const uriPrefix = `#`;\n            const defUriPrefix = `${uriPrefix}/${defsSegment}/`;\n            const defId = entry[1].schema.id ?? `__schema${this.counter++}`;\n            return { defId, ref: defUriPrefix + defId };\n        };\n        // stored cached version in `def` property\n        // remove all properties, set $ref\n        const extractToDef = (entry) => {\n            // if the schema is already a reference, do not extract it\n            if (entry[1].schema.$ref) {\n                return;\n            }\n            const seen = entry[1];\n            const { ref, defId } = makeURI(entry);\n            seen.def = { ...seen.schema };\n            // defId won't be set if the schema is a reference to an external schema\n            if (defId)\n                seen.defId = defId;\n            // wipe away all properties except $ref\n            const schema = seen.schema;\n            for (const key in schema) {\n                delete schema[key];\n            }\n            schema.$ref = ref;\n        };\n        // throw on cycles\n        // break cycles\n        if (params.cycles === \"throw\") {\n            for (const entry of this.seen.entries()) {\n                const seen = entry[1];\n                if (seen.cycle) {\n                    throw new Error(\"Cycle detected: \" +\n                        `#/${seen.cycle?.join(\"/\")}/<root>` +\n                        '\\n\\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.');\n                }\n            }\n        }\n        // extract schemas into $defs\n        for (const entry of this.seen.entries()) {\n            const seen = entry[1];\n            // convert root schema to # $ref\n            if (schema === entry[0]) {\n                extractToDef(entry); // this has special handling for the root schema\n                continue;\n            }\n            // extract schemas that are in the external registry\n            if (params.external) {\n                const ext = params.external.registry.get(entry[0])?.id;\n                if (schema !== entry[0] && ext) {\n                    extractToDef(entry);\n                    continue;\n                }\n            }\n            // extract schemas with `id` meta\n            const id = this.metadataRegistry.get(entry[0])?.id;\n            if (id) {\n                extractToDef(entry);\n                continue;\n            }\n            // break cycles\n            if (seen.cycle) {\n                // any\n                extractToDef(entry);\n                continue;\n            }\n            // extract reused schemas\n            if (seen.count > 1) {\n                if (params.reused === \"ref\") {\n                    extractToDef(entry);\n                    // biome-ignore lint:\n                    continue;\n                }\n            }\n        }\n        // flatten _refs\n        const flattenRef = (zodSchema, params) => {\n            const seen = this.seen.get(zodSchema);\n            const schema = seen.def ?? seen.schema;\n            const _cached = { ...schema };\n            // already seen\n            if (seen.ref === null) {\n                return;\n            }\n            // flatten ref if defined\n            const ref = seen.ref;\n            seen.ref = null; // prevent recursion\n            if (ref) {\n                flattenRef(ref, params);\n                // merge referenced schema into current\n                const refSchema = this.seen.get(ref).schema;\n                if (refSchema.$ref &&\n                    (params.target === \"draft-7\" || params.target === \"draft-4\" || params.target === \"openapi-3.0\")) {\n                    schema.allOf = schema.allOf ?? [];\n                    schema.allOf.push(refSchema);\n                }\n                else {\n                    Object.assign(schema, refSchema);\n                    Object.assign(schema, _cached); // prevent overwriting any fields in the original schema\n                }\n            }\n            // execute overrides\n            if (!seen.isParent)\n                this.override({\n                    zodSchema: zodSchema,\n                    jsonSchema: schema,\n                    path: seen.path ?? [],\n                });\n        };\n        for (const entry of [...this.seen.entries()].reverse()) {\n            flattenRef(entry[0], { target: this.target });\n        }\n        const result = {};\n        if (this.target === \"draft-2020-12\") {\n            result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n        }\n        else if (this.target === \"draft-7\") {\n            result.$schema = \"http://json-schema.org/draft-07/schema#\";\n        }\n        else if (this.target === \"draft-4\") {\n            result.$schema = \"http://json-schema.org/draft-04/schema#\";\n        }\n        else if (this.target === \"openapi-3.0\") {\n            // OpenAPI 3.0 schema objects should not include a $schema property\n        }\n        else {\n            // @ts-ignore\n            console.warn(`Invalid target: ${this.target}`);\n        }\n        if (params.external?.uri) {\n            const id = params.external.registry.get(schema)?.id;\n            if (!id)\n                throw new Error(\"Schema is missing an `id` property\");\n            result.$id = params.external.uri(id);\n        }\n        Object.assign(result, root.def);\n        // build defs object\n        const defs = params.external?.defs ?? {};\n        for (const entry of this.seen.entries()) {\n            const seen = entry[1];\n            if (seen.def && seen.defId) {\n                defs[seen.defId] = seen.def;\n            }\n        }\n        // set definitions in result\n        if (params.external) {\n        }\n        else {\n            if (Object.keys(defs).length > 0) {\n                if (this.target === \"draft-2020-12\") {\n                    result.$defs = defs;\n                }\n                else {\n                    result.definitions = defs;\n                }\n            }\n        }\n        try {\n            // this \"finalizes\" this schema and ensures all cycles are removed\n            // each call to .emit() is functionally independent\n            // though the seen map is shared\n            return JSON.parse(JSON.stringify(result));\n        }\n        catch (_err) {\n            throw new Error(\"Error converting schema to JSON.\");\n        }\n    }\n}\nexport function toJSONSchema(input, _params) {\n    if (input instanceof $ZodRegistry) {\n        const gen = new JSONSchemaGenerator(_params);\n        const defs = {};\n        for (const entry of input._idmap.entries()) {\n            const [_, schema] = entry;\n            gen.process(schema);\n        }\n        const schemas = {};\n        const external = {\n            registry: input,\n            uri: _params?.uri,\n            defs,\n        };\n        for (const entry of input._idmap.entries()) {\n            const [key, schema] = entry;\n            schemas[key] = gen.emit(schema, {\n                ..._params,\n                external,\n            });\n        }\n        if (Object.keys(defs).length > 0) {\n            const defsSegment = gen.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n            schemas.__shared = {\n                [defsSegment]: defs,\n            };\n        }\n        return { schemas };\n    }\n    const gen = new JSONSchemaGenerator(_params);\n    gen.process(input);\n    return gen.emit(input, _params);\n}\nfunction isTransforming(_schema, _ctx) {\n    const ctx = _ctx ?? { seen: new Set() };\n    if (ctx.seen.has(_schema))\n        return false;\n    ctx.seen.add(_schema);\n    const schema = _schema;\n    const def = schema._zod.def;\n    switch (def.type) {\n        case \"string\":\n        case \"number\":\n        case \"bigint\":\n        case \"boolean\":\n        case \"date\":\n        case \"symbol\":\n        case \"undefined\":\n        case \"null\":\n        case \"any\":\n        case \"unknown\":\n        case \"never\":\n        case \"void\":\n        case \"literal\":\n        case \"enum\":\n        case \"nan\":\n        case \"file\":\n        case \"template_literal\":\n            return false;\n        case \"array\": {\n            return isTransforming(def.element, ctx);\n        }\n        case \"object\": {\n            for (const key in def.shape) {\n                if (isTransforming(def.shape[key], ctx))\n                    return true;\n            }\n            return false;\n        }\n        case \"union\": {\n            for (const option of def.options) {\n                if (isTransforming(option, ctx))\n                    return true;\n            }\n            return false;\n        }\n        case \"intersection\": {\n            return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n        }\n        case \"tuple\": {\n            for (const item of def.items) {\n                if (isTransforming(item, ctx))\n                    return true;\n            }\n            if (def.rest && isTransforming(def.rest, ctx))\n                return true;\n            return false;\n        }\n        case \"record\": {\n            return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n        }\n        case \"map\": {\n            return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n        }\n        case \"set\": {\n            return isTransforming(def.valueType, ctx);\n        }\n        // inner types\n        case \"promise\":\n        case \"optional\":\n        case \"nonoptional\":\n        case \"nullable\":\n        case \"readonly\":\n            return isTransforming(def.innerType, ctx);\n        case \"lazy\":\n            return isTransforming(def.getter(), ctx);\n        case \"default\": {\n            return isTransforming(def.innerType, ctx);\n        }\n        case \"prefault\": {\n            return isTransforming(def.innerType, ctx);\n        }\n        case \"custom\": {\n            return false;\n        }\n        case \"transform\": {\n            return true;\n        }\n        case \"pipe\": {\n            return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n        }\n        case \"success\": {\n            return false;\n        }\n        case \"catch\": {\n            return false;\n        }\n        case \"function\": {\n            return false;\n        }\n        default:\n            def;\n    }\n    throw new Error(`Unknown schema type: ${def.type}`);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}